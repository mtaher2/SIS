<div class="container mt-4">
    <div class="row mb-4">
        <div class="col-md-8">
            <h1 class="mb-2">Manage Quiz Questions</h1>
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/">Home</a></li>
                    <li class="breadcrumb-item"><a href="/instructor/courses">My Courses</a></li>
                    <li class="breadcrumb-item"><a href="/instructor/courses/<%= course.course_id %>"><%= course.title %></a></li>
                    <li class="breadcrumb-item"><a href="/instructor/courses/<%= course.course_id %>/modules">Modules</a></li>
                    <li class="breadcrumb-item"><a href="/instructor/modules/<%= module.module_id %>/quizzes">Quizzes</a></li>
                    <li class="breadcrumb-item"><a href="/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>"><%= quiz.title %></a></li>
                    <li class="breadcrumb-item active">Questions</li>
                </ol>
            </nav>
        </div>
        <div class="col-md-4 text-end">
            <a href="/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-1"></i> Back to Quiz
            </a>
        </div>
    </div>

    <!-- Quiz Info Summary -->
    <div class="card mb-4">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0"><i class="fas fa-clipboard-list me-2"></i> <%= quiz.title %></h5>
        </div>
        <div class="card-body">
            <div class="row">
                <div class="col-md-4">
                    <p><strong>Total Points:</strong> <%= quiz.points_possible %></p>
                </div>
                <div class="col-md-4">
                    <p><strong>Total Questions:</strong> <span id="questionCount">0</span></p>
                </div>
                <div class="col-md-4">
                    <p class="<%= quiz.published ? 'text-success' : 'text-warning' %>">
                        <strong>Status:</strong> 
                        <% if(quiz.published) { %>
                            <i class="fas fa-check-circle me-1"></i> Published
                        <% } else { %>
                            <i class="fas fa-exclamation-circle me-1"></i> Draft
                        <% } %>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Add page loader overlay -->
    <style>
        #page-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.3s ease-out;
        }
        #page-loader.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        #page-loader .spinner-border {
            width: 3rem;
            height: 3rem;
        }
        #page-loader .loading-text {
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: 500;
        }
    </style>

    <div id="page-loader">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <div class="loading-text">Loading questions...</div>
    </div>

    <!-- Add Question Form -->
    <div class="card mb-4">
        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
            <h5 class="mb-0"><i class="fas fa-plus-circle me-2"></i> Add New Question</h5>
            <button class="btn btn-light btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#addQuestionForm">
                <i class="fas fa-chevron-down"></i>
            </button>
        </div>
        <div class="card-body collapse show" id="addQuestionForm">
            <form id="questionForm" action="/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions" method="POST">
                <div class="mb-3">
                    <label for="questionType" class="form-label">Question Type</label>
                    <select class="form-select" id="questionType" name="type" required>
                        <option value="">Select Question Type</option>
                        <option value="multiple_choice">Multiple Choice</option>
                        <option value="true_false">True/False</option>
                        <option value="short_answer">Short Answer</option>
                        <option value="essay">Essay</option>
                        <option value="matching">Matching</option>
                        <option value="dropdown">Dropdown</option>
                    </select>
                </div>
                
                <div class="mb-3">
                    <label for="questionText" class="form-label">Question Text</label>
                    <textarea class="form-control" id="questionText" name="question_text" rows="3" required></textarea>
                </div>
                
                <div class="mb-3">
                    <label for="points" class="form-label">Points</label>
                    <input type="number" class="form-control" id="points" name="points" min="1" value="1" required>
                </div>
                
                <!-- Options for different question types -->
                <div id="optionsContainer" class="d-none">
                    <!-- Multiple Choice Options -->
                    <div id="multipleChoiceOptions" class="d-none mb-3">
                        <label class="form-label">Answer Choices</label>
                        <div class="options-list">
                            <div class="option-item mb-2 d-flex align-items-center">
                                <div class="form-check me-2">
                                    <input class="form-check-input" type="radio" name="correct_option" value="0" checked>
                                </div>
                                <input type="text" class="form-control me-2" name="options[]" placeholder="Option 1">
                                <button type="button" class="btn btn-sm btn-outline-danger remove-option">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div class="option-item mb-2 d-flex align-items-center">
                                <div class="form-check me-2">
                                    <input class="form-check-input" type="radio" name="correct_option" value="1">
                                </div>
                                <input type="text" class="form-control me-2" name="options[]" placeholder="Option 2">
                                <button type="button" class="btn btn-sm btn-outline-danger remove-option">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary mt-2" id="addOption">
                            <i class="fas fa-plus me-1"></i> Add Another Option
                        </button>
                    </div>
                    
                    <!-- True/False Options -->
                    <div id="trueFalseOptions" class="d-none mb-3">
                        <label class="form-label">Correct Answer</label>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="true_false_correct" id="answerTrue" value="true" checked>
                            <label class="form-check-label" for="answerTrue">True</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" name="true_false_correct" id="answerFalse" value="false">
                            <label class="form-check-label" for="answerFalse">False</label>
                        </div>
                    </div>
                    
                    <!-- Short Answer Options -->
                    <div id="shortAnswerOptions" class="d-none mb-3">
                        <label class="form-label">Accepted Answers (one per line)</label>
                        <textarea class="form-control" name="short_answer_options" rows="3" placeholder="Enter all accepted answers, one per line"></textarea>
                        <div class="form-text">Case sensitivity will be ignored when grading.</div>
                    </div>
                    
                    <!-- Matching Options -->
                    <div id="matchingOptions" class="d-none mb-3">
                        <label class="form-label">Matching Pairs</label>
                        <div class="matching-pairs-list">
                            <div class="matching-pair mb-2">
                                <div class="row">
                                    <div class="col-5">
                                        <input type="text" class="form-control" name="matching_left[]" placeholder="Left side item">
                                    </div>
                                    <div class="col-5">
                                        <input type="text" class="form-control" name="matching_right[]" placeholder="Right side item">
                                    </div>
                                    <div class="col-2">
                                        <button type="button" class="btn btn-sm btn-outline-danger remove-matching-pair">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="matching-pair mb-2">
                                <div class="row">
                                    <div class="col-5">
                                        <input type="text" class="form-control" name="matching_left[]" placeholder="Left side item">
                                    </div>
                                    <div class="col-5">
                                        <input type="text" class="form-control" name="matching_right[]" placeholder="Right side item">
                                    </div>
                                    <div class="col-2">
                                        <button type="button" class="btn btn-sm btn-outline-danger remove-matching-pair">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary mt-2" id="addMatchingPair">
                            <i class="fas fa-plus me-1"></i> Add Another Pair
                        </button>
                    </div>
                    
                    <!-- Other question types would have their specific options here -->
                </div>
                
                <div class="d-flex gap-2 mt-4">
                    <button type="submit" class="btn btn-primary" id="addQuestionBtn">
                        <span class="button-text"><i class="fas fa-save me-1"></i> Add Question</span>
                        <span class="spinner-border spinner-border-sm ms-1 d-none" role="status" aria-hidden="true"></span>
                    </button>
                    <button type="button" class="btn btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#addQuestionForm">
                        Cancel
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Questions List -->
    <div class="card">
        <div class="card-header bg-primary text-white">
            <h5 class="mb-0"><i class="fas fa-list me-2"></i> Quiz Questions</h5>
        </div>
        <div class="card-body">
            <div id="questionsContainer">
                <!-- Questions will be loaded here via AJAX -->
                <div class="text-center py-5" id="loadingQuestions">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Loading questions...</p>
                </div>
                
                <div id="noQuestionsMessage" class="alert alert-info d-none">
                    <i class="fas fa-info-circle me-2"></i> No questions have been added to this quiz yet. Use the form above to add your first question.
                </div>
                
                <div id="questionsList" class="d-none">
                    <!-- Questions will be displayed here -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Question Template (for JavaScript rendering) -->
<template id="questionTemplate">
    <div class="question-item card mb-3" data-question-id="">
        <div class="card-header d-flex justify-content-between align-items-center">
            <div>
                <span class="badge bg-primary me-2 question-number"></span>
                <span class="question-type"></span>
            </div>
            <div class="question-points badge bg-secondary"></div>
        </div>
        <div class="card-body">
            <h5 class="question-text mb-3"></h5>
            
            <div class="options-container mb-3">
                <!-- Options will be inserted here -->
            </div>
            
            <div class="d-flex gap-2">
                <button type="button" class="btn btn-sm btn-outline-primary edit-question">
                    <i class="fas fa-edit me-1"></i> Edit
                </button>
                <button type="button" class="btn btn-sm btn-outline-danger delete-question">
                    <i class="fas fa-trash me-1"></i> Delete
                </button>
            </div>
        </div>
    </div>
</template>

<!-- Edit Question Modal -->
<div class="modal fade" id="editQuestionModal" tabindex="-1" aria-labelledby="editQuestionModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editQuestionModalLabel">Edit Question</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="editQuestionForm">
                    <input type="hidden" id="editQuestionId" name="question_id">
                    
                    <div class="mb-3">
                        <label for="editQuestionText" class="form-label">Question Text</label>
                        <textarea class="form-control" id="editQuestionText" name="question_text" rows="3" required></textarea>
                    </div>
                    
                    <div class="mb-3">
                        <label for="editPoints" class="form-label">Points</label>
                        <input type="number" class="form-control" id="editPoints" name="points" min="1" value="1" required>
                    </div>
                    
                    <div id="editOptionsContainer">
                        <!-- Options will be dynamically inserted based on question type -->
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveQuestionChanges">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade" id="deleteQuestionModal" tabindex="-1" aria-labelledby="deleteQuestionModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="deleteQuestionModalLabel">Confirm Delete</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this question? This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirmDeleteQuestion">Delete</button>
            </div>
        </div>
    </div>
</div>

<!-- Add custom toast notification container at the end of the body but before scripts -->
<div id="toast-container" class="position-fixed top-0 end-0 p-3" style="z-index: 1080;"></div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Show page loader initially
        const pageLoader = document.getElementById('page-loader');
        
        // Hide page loader after a short delay to ensure everything is loaded
        window.addEventListener('load', function() {
            setTimeout(() => {
                pageLoader.classList.add('fade-out');
                setTimeout(() => {
                    pageLoader.style.display = 'none';
                }, 300);
            }, 500);
        });
        
        // Variables to track state
        let questionType = '';
        let currentQuestionId = null;
        const questionsList = [];
        let isLoading = false;
        
        // Toast notification function
        function showToast(message, type = 'success') {
            const toastContainer = document.getElementById('toast-container');
            const id = 'toast-' + Date.now();
            
            // Create toast element
            const toastEl = document.createElement('div');
            toastEl.className = `toast align-items-center border-0 fade show`;
            toastEl.setAttribute('role', 'alert');
            toastEl.setAttribute('aria-live', 'assertive');
            toastEl.setAttribute('aria-atomic', 'true');
            toastEl.id = id;
            
            // Set background color based on type
            let bgColor = 'bg-success';
            let icon = '<i class="fas fa-check-circle me-2"></i>';
            
            if (type === 'error') {
                bgColor = 'bg-danger';
                icon = '<i class="fas fa-exclamation-circle me-2"></i>';
            } else if (type === 'warning') {
                bgColor = 'bg-warning';
                icon = '<i class="fas fa-exclamation-triangle me-2"></i>';
            } else if (type === 'info') {
                bgColor = 'bg-info';
                icon = '<i class="fas fa-info-circle me-2"></i>';
            }
            
            // Set the toast content
            toastEl.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body text-white ${bgColor}">
                        ${icon} ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            
            // Add to container
            toastContainer.appendChild(toastEl);
            
            // Initialize Bootstrap toast
            const toast = new bootstrap.Toast(toastEl, {
                autohide: true,
                delay: 2000
            });
            
            // Show the toast
            toast.show();
            
            // Remove from DOM after hidden
            toastEl.addEventListener('hidden.bs.toast', function() {
                toastEl.remove();
            });
        }
        
        // Function to set loading state
        function setLoading(isLoading) {
            const addQuestionBtn = document.getElementById('addQuestionBtn');
            const spinner = addQuestionBtn.querySelector('.spinner-border');
            const buttonText = addQuestionBtn.querySelector('.button-text');
            
            if (isLoading) {
                // Disable button and show spinner
                addQuestionBtn.disabled = true;
                spinner.classList.remove('d-none');
                buttonText.textContent = ' Adding...';
            } else {
                // Enable button and hide spinner
                addQuestionBtn.disabled = false;
                spinner.classList.add('d-none');
                buttonText.innerHTML = '<i class="fas fa-save me-1"></i> Add Question';
            }
        }
        
        // DOM elements
        const questionTypeSelect = document.getElementById('questionType');
        const optionsContainer = document.getElementById('optionsContainer');
        const multipleChoiceOptions = document.getElementById('multipleChoiceOptions');
        const trueFalseOptions = document.getElementById('trueFalseOptions');
        const shortAnswerOptions = document.getElementById('shortAnswerOptions');
        const addOptionBtn = document.getElementById('addOption');
        const questionForm = document.getElementById('questionForm');
        
        // Function to toggle required attribute on form fields
        function toggleRequiredAttributes() {
            // Remove required attribute from all option inputs
            document.querySelectorAll('[name="options[]"]').forEach(el => {
                el.required = (questionType === 'multiple_choice' || questionType === 'dropdown');
            });
            
            // Remove required attribute from matching inputs
            document.querySelectorAll('[name="matching_left[]"], [name="matching_right[]"]').forEach(el => {
                el.required = (questionType === 'matching');
            });
            
            // Handle short answer required fields
            const shortAnswerTextarea = document.querySelector('[name="short_answer_options"]');
            if (shortAnswerTextarea) {
                shortAnswerTextarea.required = (questionType === 'short_answer');
            }
        }
        
        // Handle question type change
        questionTypeSelect.addEventListener('change', function() {
            questionType = this.value;
            
            // Hide all option containers first
            optionsContainer.classList.add('d-none');
            multipleChoiceOptions.classList.add('d-none');
            trueFalseOptions.classList.add('d-none');
            shortAnswerOptions.classList.add('d-none');
            const matchingOptions = document.getElementById('matchingOptions');
            if (matchingOptions) matchingOptions.classList.add('d-none');
            
            // Show appropriate options based on question type
            if (questionType === 'multiple_choice' || questionType === 'dropdown') {
                optionsContainer.classList.remove('d-none');
                multipleChoiceOptions.classList.remove('d-none');
            } else if (questionType === 'true_false') {
                optionsContainer.classList.remove('d-none');
                trueFalseOptions.classList.remove('d-none');
            } else if (questionType === 'short_answer') {
                optionsContainer.classList.remove('d-none');
                shortAnswerOptions.classList.remove('d-none');
            } else if (questionType === 'matching') {
                optionsContainer.classList.remove('d-none');
                matchingOptions.classList.remove('d-none');
            }
            
            // Update required attributes based on question type
            toggleRequiredAttributes();
        });
        
        // Add new option field for multiple choice
        addOptionBtn?.addEventListener('click', function() {
            const optionsList = document.querySelector('.options-list');
            const optionCount = optionsList.querySelectorAll('.option-item').length;
            
            const newOption = document.createElement('div');
            newOption.className = 'option-item mb-2 d-flex align-items-center';
            newOption.innerHTML = `
                <div class="form-check me-2">
                    <input class="form-check-input" type="radio" name="correct_option" value="${optionCount}">
                </div>
                <input type="text" class="form-control me-2" name="options[]" placeholder="Option ${optionCount + 1}" ${questionType === 'multiple_choice' || questionType === 'dropdown' ? 'required' : ''}>
                <button type="button" class="btn btn-sm btn-outline-danger remove-option">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            optionsList.appendChild(newOption);
            attachRemoveOptionListeners();
        });
        
        // Remove option field
        function attachRemoveOptionListeners() {
            document.querySelectorAll('.remove-option').forEach(button => {
                button.addEventListener('click', function() {
                    // Don't remove if there are only 2 options left
                    const optionItems = document.querySelectorAll('.option-item');
                    if (optionItems.length <= 2) {
                        alert('A multiple choice question must have at least 2 options.');
                        return;
                    }
                    
                    this.closest('.option-item').remove();
                    // Reassign values for remaining options
                    document.querySelectorAll('.option-item').forEach((item, index) => {
                        item.querySelector('input[type="radio"]').value = index;
                        item.querySelector('input[type="text"]').placeholder = `Option ${index + 1}`;
                    });
                });
            });
        }
        
        attachRemoveOptionListeners();
        
        // Add new matching pair
        document.getElementById('addMatchingPair')?.addEventListener('click', function() {
            const pairsList = document.querySelector('.matching-pairs-list');
            const pairCount = pairsList.querySelectorAll('.matching-pair').length;
            
            const newPair = document.createElement('div');
            newPair.className = 'matching-pair mb-2';
            newPair.innerHTML = `
                <div class="row">
                    <div class="col-5">
                        <input type="text" class="form-control" name="matching_left[]" placeholder="Left side item" ${questionType === 'matching' ? 'required' : ''}>
                    </div>
                    <div class="col-5">
                        <input type="text" class="form-control" name="matching_right[]" placeholder="Right side item" ${questionType === 'matching' ? 'required' : ''}>
                    </div>
                    <div class="col-2">
                        <button type="button" class="btn btn-sm btn-outline-danger remove-matching-pair">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            `;
            
            pairsList.appendChild(newPair);
            attachRemoveMatchingPairListeners();
        });
        
        // Remove matching pair
        function attachRemoveMatchingPairListeners() {
            document.querySelectorAll('.remove-matching-pair').forEach(button => {
                button.addEventListener('click', function() {
                    // Don't remove if there are only 2 pairs left
                    const pairItems = document.querySelectorAll('.matching-pair');
                    if (pairItems.length <= 2) {
                        showToast('A matching question must have at least 2 pairs.', 'warning');
                        return;
                    }
                    
                    this.closest('.matching-pair').remove();
                });
            });
        }
        
        // Attach initial event listeners
        attachRemoveMatchingPairListeners();
        
        // Load questions on page load
        function loadQuestions() {
            // Show loading state
            document.getElementById('loadingQuestions').classList.remove('d-none');
            document.getElementById('noQuestionsMessage').classList.add('d-none');
            document.getElementById('questionsList').classList.add('d-none');
            
            fetch(`/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions/data`)
                .then(response => response.json())
                .then(data => {
                    // Update question count
                    document.getElementById('questionCount').textContent = data.questions.length;
                    console.log('Received questions data:', data);
                    
                    // Hide loading indicator
                    document.getElementById('loadingQuestions').classList.add('d-none');
                    
                    if (data.questions.length === 0) {
                        // Show no questions message
                        document.getElementById('noQuestionsMessage').classList.remove('d-none');
                    } else {
                        // Show questions list and render questions
                        document.getElementById('questionsList').classList.remove('d-none');
                        renderQuestions(data.questions);
                    }
                })
                .catch(error => {
                    console.error('Error loading questions:', error);
                    document.getElementById('loadingQuestions').classList.add('d-none');
                    document.getElementById('noQuestionsMessage').textContent = 'Error loading questions. Please refresh the page to try again.';
                    document.getElementById('noQuestionsMessage').classList.remove('d-none');
                });
        }
        
        // Initialize the page
        loadQuestions();
        
        // Form submission - add custom validation
        questionForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Prevent multiple submissions
            if (isLoading) {
                return;
            }
            
            // First, update required attributes based on current question type
            toggleRequiredAttributes();
            
            // Client-side validation
            if (!questionTypeSelect.value) {
                showToast('Please select a question type', 'warning');
                return;
            }
            
            // Special validation for different question types
            if (questionType === 'short_answer') {
                const shortAnswerText = document.querySelector('[name="short_answer_options"]').value;
                const answers = shortAnswerText.split('\n').filter(a => a.trim());
                if (answers.length === 0) {
                    showToast('Please enter at least one accepted answer', 'warning');
                    return;
                }
            } else if (questionType === 'true_false') {
                if (!document.querySelector('input[name="true_false_correct"]:checked')) {
                    showToast('Please select the correct answer (True or False)', 'warning');
                    return;
                }
            } else if (questionType === 'multiple_choice' || questionType === 'dropdown') {
                // Check for minimum options
                const options = document.querySelectorAll('input[name="options[]"]');
                if (options.length < 2) {
                    showToast('Multiple choice questions must have at least 2 options', 'warning');
                    return;
                }
                
                // Check if a correct option is selected
                if (!document.querySelector('input[name="correct_option"]:checked')) {
                    showToast('Please select a correct answer', 'warning');
                    return;
                }
                
                // Check for empty options
                let hasEmptyOption = false;
                options.forEach(input => {
                    if (!input.value.trim()) hasEmptyOption = true;
                });
                
                if (hasEmptyOption) {
                    showToast('All options must have text', 'warning');
                    return;
                }
            } else if (questionType === 'matching') {
                // Check minimum pairs
                const leftItems = document.querySelectorAll('input[name="matching_left[]"]');
                const rightItems = document.querySelectorAll('input[name="matching_right[]"]');
                
                if (leftItems.length < 2) {
                    showToast('Matching questions must have at least 2 pairs', 'warning');
                    return;
                }
                
                // Check for empty items
                let hasEmptyItem = false;
                leftItems.forEach(input => {
                    if (!input.value.trim()) hasEmptyItem = true;
                });
                rightItems.forEach(input => {
                    if (!input.value.trim()) hasEmptyItem = true;
                });
                
                if (hasEmptyItem) {
                    showToast('All matching items must have text', 'warning');
                    return;
                }
            }
            
            // Show loading indicator
            isLoading = true;
            setLoading(true);
            
            // Continue with form data processing...
            const formData = new FormData(this);
            const data = {
                type: formData.get('type'),
                question_text: formData.get('question_text'),
                points: formData.get('points') || 1,
                options: []
            };
            
            // Process different question types
            if (data.type === 'multiple_choice' || data.type === 'dropdown') {
                // Handle multiple choice options
                const optionsArray = formData.getAll('options[]');
                const correctOption = formData.get('correct_option');
                
                data.options = optionsArray.map((text, index) => {
                    return {
                        option_text: text,
                        is_correct: index.toString() === correctOption
                    };
                });
            } else if (data.type === 'true_false') {
                // Handle true/false
                const trueFalseCorrect = formData.get('true_false_correct');
                
                // Set the true_false_correct value to be processed by the server
                data.true_false_correct = trueFalseCorrect;
                data.options = [
                    { option_text: 'True', is_correct: trueFalseCorrect === 'true' },
                    { option_text: 'False', is_correct: trueFalseCorrect === 'false' }
                ];
            } else if (data.type === 'short_answer') {
                // Handle short answer
                const shortAnswerOptions = formData.get('short_answer_options') || '';
                const acceptedAnswers = shortAnswerOptions.split('\n')
                    .map(a => a.trim())
                    .filter(a => a.length > 0);
                
                data.options = acceptedAnswers.map(text => ({ option_text: text, is_correct: true }));
            } else if (data.type === 'essay') {
                // Essay doesn't need options
                data.options = [];
            } else if (data.type === 'matching') {
                // Handle matching question type
                const leftItems = formData.getAll('matching_left[]');
                const rightItems = formData.getAll('matching_right[]');
                
                // Create the options array from pairs
                data.options = [];
                for (let i = 0; i < leftItems.length; i++) {
                    data.options.push({
                        option_text: leftItems[i],
                        is_correct: true,
                        matching_id: i,
                        side: 'left'
                    });
                    
                    data.options.push({
                        option_text: rightItems[i],
                        is_correct: true,
                        matching_id: i,
                        side: 'right'
                    });
                }
            }
            
            // Validate the question
            if (data.question_text.trim() === '') {
                showToast('Please enter a question text', 'warning');
                setLoading(false);
                isLoading = false;
                return;
            }
            
            console.log('Final data being submitted:', data);
            
            // Submit the data
            fetch(`/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                // Log the raw response for debugging
                console.log('Server response status:', response.status);
                
                // Check if the response is JSON
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('application/json')) {
                    return response.json().then(data => {
                        return { status: response.status, body: data };
                    });
                } else {
                    // For non-JSON responses, try to resubmit automatically
                    console.warn('Server returned non-JSON response - trying again...');
                    return new Promise(resolve => {
                        // Wait 2 seconds and try again
                        setTimeout(() => {
                            fetch(`/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions/data`)
                                .then(res => res.json())
                                .then(data => {
                                    // If we can fetch questions, assume creation was successful
                                    console.log('Recheck successful, question was likely created');
                                    resolve({ 
                                        status: 200, 
                                        body: { 
                                            success: true, 
                                            message: 'Question likely added successfully' 
                                        } 
                                    });
                                })
                                .catch(err => {
                                    console.error('Recheck failed:', err);
                                    resolve({ 
                                        status: response.status, 
                                        body: { 
                                            success: false, 
                                            message: 'Error verifying question creation' 
                                        } 
                                    });
                                });
                        }, 2000);
                    });
                }
            })
            .then(result => {
                console.log('Parsed response:', result);
                // Reset loading state
                isLoading = false;
                setLoading(false);
                
                if (result.body.success) {
                    // Reset form
                    this.reset();
                    questionTypeSelect.dispatchEvent(new Event('change'));
                    
                    // Reload questions
                    loadQuestions();
                    
                    // Show success message with toast instead of alert
                    showToast('Question added successfully!', 'success');
                } else {
                    // Show detailed error message
                    const errorMsg = result.body.message || 'Unknown error occurred';
                    console.error('Error details:', result);
                    showToast(`Error: ${errorMsg}`, 'error');
                }
            })
            .catch(error => {
                // Reset loading state
                isLoading = false;
                setLoading(false);
                
                // Log detailed error information
                console.error('Error adding question:', error);
                showToast(`An error occurred: ${error.message || 'Unknown error'}`, 'error');
            });
        });
        
        // Initialize form with the right required attributes
        toggleRequiredAttributes();
        
        // Render questions function
        function renderQuestions(questions) {
            console.log('Rendering questions:', questions);
            const questionsList = document.getElementById('questionsList');
            questionsList.innerHTML = '';
            
            questions.forEach((question, index) => {
                console.log(`Rendering question ${index+1}:`, question);
                const template = document.getElementById('questionTemplate');
                const questionElement = template.content.cloneNode(true);
                
                // Set question data
                const questionItem = questionElement.querySelector('.question-item');
                questionItem.dataset.questionId = question.question_id;
                
                // Set question number
                questionElement.querySelector('.question-number').textContent = `Q${index + 1}`;
                
                // Set question type
                const questionType = questionElement.querySelector('.question-type');
                let typeText = 'Unknown';
                let typeBadgeClass = 'bg-secondary';
                
                switch(question.type) {
                    case 'multiple_choice':
                        typeText = 'Multiple Choice';
                        typeBadgeClass = 'bg-primary';
                        break;
                    case 'true_false':
                        typeText = 'True/False';
                        typeBadgeClass = 'bg-info';
                        break;
                    case 'short_answer':
                        typeText = 'Short Answer';
                        typeBadgeClass = 'bg-success';
                        break;
                    case 'essay':
                        typeText = 'Essay';
                        typeBadgeClass = 'bg-warning';
                        break;
                    case 'matching':
                        typeText = 'Matching';
                        typeBadgeClass = 'bg-danger';
                        break;
                    case 'dropdown':
                        typeText = 'Dropdown';
                        typeBadgeClass = 'bg-dark';
                        break;
                    default:
                        typeText = question.type || 'Unknown';
                        break;
                }
                
                // Create type badge
                const typeBadge = document.createElement('span');
                typeBadge.className = `badge ${typeBadgeClass} me-2`;
                typeBadge.textContent = typeText;
                questionType.appendChild(typeBadge);
                
                // Set question points
                questionElement.querySelector('.question-points').textContent = `${question.points} pt${question.points !== 1 ? 's' : ''}`;
                
                // Set question text
                questionElement.querySelector('.question-text').textContent = question.question_text;
                
                // Set options if present
                const optionsContainer = questionElement.querySelector('.options-container');
                
                console.log(`Question ${index+1} type:`, question.type);
                console.log(`Question ${index+1} options:`, question.options);
                
                if (question.type === 'essay') {
                    // Essay questions don't have options
                    optionsContainer.innerHTML = '<div class="text-muted fst-italic">Essay question - student will provide free-form response</div>';
                } else if (question.type === 'matching') {
                    // For matching questions, group the options by matching_id
                    const matchingPairs = {};
                    
                    // Group options by matching_id
                    question.options.forEach(option => {
                        if (option.matching_id === null && option.matching_id !== 0) {
                            console.warn('Missing matching_id in option:', option);
                            return;
                        }
                        
                        if (!matchingPairs[option.matching_id]) {
                            matchingPairs[option.matching_id] = { left: null, right: null };
                        }
                        
                        if (option.side === 'left') {
                            matchingPairs[option.matching_id].left = option.option_text;
                        } else if (option.side === 'right') {
                            matchingPairs[option.matching_id].right = option.option_text;
                        } else {
                            console.warn('Invalid side value in matching option:', option);
                        }
                    });
                    
                    console.log('Processed matching pairs:', matchingPairs);
                    
                    // Create a table for matching pairs
                    const table = document.createElement('table');
                    table.className = 'table table-bordered';
                    table.innerHTML = `
                        <thead>
                            <tr>
                                <th>Left Side</th>
                                <th>Right Side</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${Object.entries(matchingPairs).map(([id, pair]) => `
                                <tr>
                                    <td>${pair.left || ''}</td>
                                    <td>${pair.right || ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    `;
                    
                    optionsContainer.appendChild(table);
                } else if (question.type === 'short_answer' && question.options && question.options.length > 0) {
                    // Display accepted answers for short answer questions
                    const acceptedAnswersList = document.createElement('div');
                    acceptedAnswersList.innerHTML = '<div class="mb-2"><strong>Accepted Answers:</strong></div>';
                    
                    const answersList = document.createElement('ul');
                    answersList.className = 'list-group';
                    
                    question.options.forEach(option => {
                        const answerItem = document.createElement('li');
                        answerItem.className = 'list-group-item';
                        answerItem.textContent = option.option_text;
                        answersList.appendChild(answerItem);
                    });
                    
                    acceptedAnswersList.appendChild(answersList);
                    optionsContainer.appendChild(acceptedAnswersList);
                } else if (question.options && question.options.length > 0) {
                    const optionsList = document.createElement('ul');
                    optionsList.className = 'list-group mb-3';
                    
                    question.options.forEach(option => {
                        const optionItem = document.createElement('li');
                        optionItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                        
                        if (question.type === 'true_false') {
                            // Use a different styling for true/false
                            optionItem.textContent = option.option_text;
                            if (option.is_correct) {
                                optionItem.classList.add('list-group-item-success');
                            }
                        } else {
                            // Standard options display
                            optionItem.textContent = option.option_text;
                            
                            if (option.is_correct) {
                                const badge = document.createElement('span');
                                badge.className = 'badge bg-success';
                                badge.textContent = 'Correct';
                                optionItem.appendChild(badge);
                            }
                        }
                        
                        optionsList.appendChild(optionItem);
                    });
                    
                    optionsContainer.appendChild(optionsList);
                } else {
                    optionsContainer.innerHTML = '<p class="text-muted">No options for this question type</p>';
                }
                
                // Add event listeners for edit and delete buttons
                const editButton = questionElement.querySelector('.edit-question');
                editButton.addEventListener('click', () => {
                    // Open edit modal with this question's data
                    openEditModal(question);
                });
                
                const deleteButton = questionElement.querySelector('.delete-question');
                deleteButton.addEventListener('click', () => {
                    // Open delete confirmation modal
                    openDeleteModal(question.question_id);
                });
                
                // Add to questions list
                questionsList.appendChild(questionItem);
            });
        }
        
        // Function to open edit modal
        function openEditModal(question) {
            currentQuestionId = question.question_id;
            
            // Set form values
            document.getElementById('editQuestionId').value = question.question_id;
            document.getElementById('editQuestionText').value = question.question_text;
            document.getElementById('editPoints').value = question.points;
            
            // Clear previous options content
            const editOptionsContainer = document.getElementById('editOptionsContainer');
            editOptionsContainer.innerHTML = '';
            
            // Set options based on question type
            if (question.type === 'multiple_choice' || question.type === 'dropdown') {
                // Create options interface
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'mb-3';
                optionsDiv.innerHTML = `
                    <label class="form-label">Answer Choices</label>
                    <div class="edit-options-list">
                        <!-- Options will be added here -->
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-secondary mt-2" id="editAddOption">
                        <i class="fas fa-plus me-1"></i> Add Another Option
                    </button>
                `;
                
                editOptionsContainer.appendChild(optionsDiv);
                
                const optionsList = optionsDiv.querySelector('.edit-options-list');
                
                // Add each option
                question.options.forEach((option, index) => {
                    const optionItem = document.createElement('div');
                    optionItem.className = 'option-item mb-2 d-flex align-items-center';
                    optionItem.innerHTML = `
                        <div class="form-check me-2">
                            <input class="form-check-input" type="radio" name="edit_correct_option" value="${index}" ${option.is_correct ? 'checked' : ''}>
                        </div>
                        <input type="text" class="form-control me-2" name="edit_options[]" value="${option.option_text}" required>
                        <button type="button" class="btn btn-sm btn-outline-danger remove-edit-option">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    
                    optionsList.appendChild(optionItem);
                });
                
                // Add event listener for add option button
                document.getElementById('editAddOption').addEventListener('click', function() {
                    const optionItem = document.createElement('div');
                    optionItem.className = 'option-item mb-2 d-flex align-items-center';
                    
                    const newIndex = optionsList.querySelectorAll('.option-item').length;
                    
                    optionItem.innerHTML = `
                        <div class="form-check me-2">
                            <input class="form-check-input" type="radio" name="edit_correct_option" value="${newIndex}">
                        </div>
                        <input type="text" class="form-control me-2" name="edit_options[]" placeholder="Option ${newIndex + 1}" required>
                        <button type="button" class="btn btn-sm btn-outline-danger remove-edit-option">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    
                    optionsList.appendChild(optionItem);
                    attachEditRemoveOptionListeners();
                });
                
                // Attach remove option listeners
                attachEditRemoveOptionListeners();
                
            } else if (question.type === 'true_false') {
                // Create true/false options
                const trueFalseDiv = document.createElement('div');
                trueFalseDiv.className = 'mb-3';
                
                // Find which option is correct
                const correctOption = question.options.find(opt => opt.is_correct);
                const isTrueCorrect = correctOption && correctOption.option_text === 'True';
                
                trueFalseDiv.innerHTML = `
                    <label class="form-label">Correct Answer</label>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="edit_true_false_correct" id="editAnswerTrue" value="true" ${isTrueCorrect ? 'checked' : ''}>
                        <label class="form-check-label" for="editAnswerTrue">True</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="edit_true_false_correct" id="editAnswerFalse" value="false" ${!isTrueCorrect ? 'checked' : ''}>
                        <label class="form-check-label" for="editAnswerFalse">False</label>
                    </div>
                `;
                
                editOptionsContainer.appendChild(trueFalseDiv);
                
            } else if (question.type === 'short_answer') {
                // Create short answer field
                const shortAnswerDiv = document.createElement('div');
                shortAnswerDiv.className = 'mb-3';
                
                // Get all accepted answers
                const acceptedAnswers = question.options.map(opt => opt.option_text).join('\n');
                
                shortAnswerDiv.innerHTML = `
                    <label class="form-label">Accepted Answers (one per line)</label>
                    <textarea class="form-control" name="edit_short_answer_options" rows="3" placeholder="Enter all accepted answers, one per line">${acceptedAnswers}</textarea>
                    <div class="form-text">Case sensitivity will be ignored when grading.</div>
                `;
                
                editOptionsContainer.appendChild(shortAnswerDiv);
            } else if (question.type === 'matching') {
                // Create matching pairs interface
                const matchingDiv = document.createElement('div');
                matchingDiv.className = 'mb-3';
                matchingDiv.innerHTML = `
                    <label class="form-label">Matching Pairs</label>
                    <div class="edit-matching-pairs-list">
                        <!-- Matching pairs will be added here -->
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-secondary mt-2" id="editAddMatchingPair">
                        <i class="fas fa-plus me-1"></i> Add Another Pair
                    </button>
                `;
                
                editOptionsContainer.appendChild(matchingDiv);
                
                const pairsList = matchingDiv.querySelector('.edit-matching-pairs-list');
                
                // Group options by matching_id
                const matchingPairs = {};
                question.options.forEach(option => {
                    if (!matchingPairs[option.matching_id]) {
                        matchingPairs[option.matching_id] = { left: null, right: null };
                    }
                    
                    if (option.side === 'left') {
                        matchingPairs[option.matching_id].left = option.option_text;
                    } else {
                        matchingPairs[option.matching_id].right = option.option_text;
                    }
                });
                
                // Add each matching pair
                Object.values(matchingPairs).forEach(pair => {
                    const pairItem = document.createElement('div');
                    pairItem.className = 'matching-pair mb-2';
                    pairItem.innerHTML = `
                        <div class="row">
                            <div class="col-5">
                                <input type="text" class="form-control" name="edit_matching_left[]" value="${pair.left || ''}" placeholder="Left side item" required>
                            </div>
                            <div class="col-5">
                                <input type="text" class="form-control" name="edit_matching_right[]" value="${pair.right || ''}" placeholder="Right side item" required>
                            </div>
                            <div class="col-2">
                                <button type="button" class="btn btn-sm btn-outline-danger remove-edit-matching-pair">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    pairsList.appendChild(pairItem);
                });
                
                // Add event listener for add pair button
                document.getElementById('editAddMatchingPair').addEventListener('click', function() {
                    const pairItem = document.createElement('div');
                    pairItem.className = 'matching-pair mb-2';
                    pairItem.innerHTML = `
                        <div class="row">
                            <div class="col-5">
                                <input type="text" class="form-control" name="edit_matching_left[]" placeholder="Left side item" required>
                            </div>
                            <div class="col-5">
                                <input type="text" class="form-control" name="edit_matching_right[]" placeholder="Right side item" required>
                            </div>
                            <div class="col-2">
                                <button type="button" class="btn btn-sm btn-outline-danger remove-edit-matching-pair">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    pairsList.appendChild(pairItem);
                    attachEditMatchingPairListeners();
                });
                
                // Attach remove pair listeners
                attachEditMatchingPairListeners();
            }
            
            // Show modal
            const editModal = new bootstrap.Modal(document.getElementById('editQuestionModal'));
            editModal.show();
        }
        
        // Function to attach remove option listeners for edit modal
        function attachEditRemoveOptionListeners() {
            document.querySelectorAll('.remove-edit-option').forEach(button => {
                button.addEventListener('click', function() {
                    const optionItems = document.querySelectorAll('.edit-options-list .option-item');
                    
                    // Don't remove if there are only 2 options left
                    if (optionItems.length <= 2) {
                        showToast('A multiple choice question must have at least 2 options.', 'warning');
                        return;
                    }
                    
                    this.closest('.option-item').remove();
                    
                    // Reassign values for remaining options
                    document.querySelectorAll('.edit-options-list .option-item').forEach((item, index) => {
                        item.querySelector('input[type="radio"]').value = index;
                    });
                });
            });
        }
        
        // Function to attach remove matching pair listeners for edit modal
        function attachEditMatchingPairListeners() {
            document.querySelectorAll('.remove-edit-matching-pair').forEach(button => {
                button.addEventListener('click', function() {
                    const pairItems = document.querySelectorAll('.edit-matching-pairs-list .matching-pair');
                    
                    // Don't remove if there are only 2 pairs left
                    if (pairItems.length <= 2) {
                        showToast('A matching question must have at least 2 pairs.', 'warning');
                        return;
                    }
                    
                    this.closest('.matching-pair').remove();
                });
            });
        }
        
        // Save edited question
        document.getElementById('saveQuestionChanges').addEventListener('click', function() {
            const button = this;
            const originalContent = button.innerHTML;
            let isSaving = false;
            
            // Prevent duplicate submissions
            if (isSaving) return;
            
            // Show loading spinner
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
            button.disabled = true;
            isSaving = true;
            
            const questionId = document.getElementById('editQuestionId').value;
            const questionText = document.getElementById('editQuestionText').value;
            const points = document.getElementById('editPoints').value;
            
            // Determine question type from the original question
            const questionItem = document.querySelector(`.question-item[data-question-id="${questionId}"]`);
            const questionTypeText = questionItem.querySelector('.question-type .badge').textContent.trim();
            
            let type = '';
            switch(questionTypeText) {
                case 'Multiple Choice': type = 'multiple_choice'; break;
                case 'True/False': type = 'true_false'; break;
                case 'Short Answer': type = 'short_answer'; break;
                case 'Essay': type = 'essay'; break;
                case 'Matching': type = 'matching'; break;
                case 'Dropdown': type = 'dropdown'; break;
            }
            
            // Prepare question data
            const questionData = {
                type: type,
                question_text: questionText,
                points: points,
                options: []
            };
            
            // Process different question types
            if (type === 'multiple_choice' || type === 'dropdown') {
                // Get option values and correct option
                const optionInputs = document.querySelectorAll('input[name="edit_options[]"]');
                const correctOption = document.querySelector('input[name="edit_correct_option"]:checked');
                
                if (!correctOption) {
                    showToast('Please select a correct answer.', 'error');
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    isSaving = false;
                    return;
                }
                
                // Check if any option is empty
                let hasEmptyOption = false;
                optionInputs.forEach(input => {
                    if (!input.value.trim()) {
                        hasEmptyOption = true;
                    }
                });
                
                if (hasEmptyOption) {
                    showToast('All options must have text.', 'error');
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    isSaving = false;
                    return;
                }
                
                optionInputs.forEach((input, index) => {
                    questionData.options.push({
                        option_text: input.value,
                        is_correct: parseInt(correctOption.value) === index
                    });
                });
                
            } else if (type === 'true_false') {
                // Process true/false options
                const trueFalseCorrect = document.querySelector('input[name="edit_true_false_correct"]:checked').value;
                
                questionData.options = [
                    { option_text: 'True', is_correct: trueFalseCorrect === 'true' },
                    { option_text: 'False', is_correct: trueFalseCorrect === 'false' }
                ];
                
            } else if (type === 'short_answer') {
                // Process short answer options
                const shortAnswerText = document.querySelector('textarea[name="edit_short_answer_options"]').value;
                const acceptedAnswers = shortAnswerText.split('\n').filter(a => a.trim());
                
                questionData.options = acceptedAnswers.map(text => ({ 
                    option_text: text, 
                    is_correct: true 
                }));
            } else if (type === 'matching') {
                // Get matching items
                const leftItems = document.querySelectorAll('input[name="edit_matching_left[]"]');
                const rightItems = document.querySelectorAll('input[name="edit_matching_right[]"]');
                
                // Check if any item is empty
                let hasEmptyItem = false;
                leftItems.forEach(input => {
                    if (!input.value.trim()) hasEmptyItem = true;
                });
                rightItems.forEach(input => {
                    if (!input.value.trim()) hasEmptyItem = true;
                });
                
                if (hasEmptyItem) {
                    showToast('All matching items must have text.', 'error');
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    isSaving = false;
                    return;
                }
                
                // Check minimum pairs
                if (leftItems.length < 2) {
                    showToast('Matching questions must have at least 2 pairs.', 'error');
                    button.innerHTML = originalContent;
                    button.disabled = false;
                    isSaving = false;
                    return;
                }
                
                // Create options array from pairs
                for (let i = 0; i < leftItems.length; i++) {
                    questionData.options.push({
                        option_text: leftItems[i].value,
                        is_correct: true,
                        matching_id: i,
                        side: 'left'
                    });
                    
                    questionData.options.push({
                        option_text: rightItems[i].value,
                        is_correct: true,
                        matching_id: i,
                        side: 'right'
                    });
                }
            }
            
            // Validate the question
            if (questionData.question_text.trim() === '') {
                showToast('Please enter a question text', 'error');
                button.innerHTML = originalContent;
                button.disabled = false;
                isSaving = false;
                return;
            }
            
            if ((type === 'multiple_choice' || type === 'dropdown') && questionData.options.length < 2) {
                showToast('Multiple choice questions must have at least 2 options', 'error');
                button.innerHTML = originalContent;
                button.disabled = false;
                isSaving = false;
                return;
            }
            
            if (type === 'short_answer' && questionData.options.length === 0) {
                showToast('Short answer questions must have at least one accepted answer', 'error');
                button.innerHTML = originalContent;
                button.disabled = false;
                isSaving = false;
                return;
            }
            
            // Submit the data
            fetch(`/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions/${questionId}`, {
                method: 'PUT',
                headers: { 
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(questionData)
            })
            .then(response => {
                // Handle response similarly to question creation
                console.log('Server response status:', response.status);
                
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    return response.json().then(data => {
                        return { status: response.status, body: data };
                    });
                } else {
                    console.warn('Server returned non-JSON response - checking update status...');
                    return new Promise(resolve => {
                        setTimeout(() => {
                            // Assume success and reload questions
                            resolve({ 
                                status: 200, 
                                body: { 
                                    success: true, 
                                    message: 'Question likely updated successfully' 
                                } 
                            });
                        }, 1000);
                    });
                }
            })
            .then(result => {
                // Reset button state
                button.innerHTML = originalContent;
                button.disabled = false;
                isSaving = false;
                
                if (result.body.success) {
                    // Close modal
                    const editModal = bootstrap.Modal.getInstance(document.getElementById('editQuestionModal'));
                    editModal.hide();
                    
                    // Reload questions
                    loadQuestions();
                    
                    // Show success message
                    showToast('Question updated successfully!', 'success');
                } else {
                    // Show error message
                    showToast(`Error: ${result.body.message || 'Failed to update question'}`, 'error');
                }
            })
            .catch(error => {
                // Reset button state
                button.innerHTML = originalContent;
                button.disabled = false;
                isSaving = false;
                
                console.error('Error updating question:', error);
                showToast(`An error occurred: ${error.message || 'Unknown error'}`, 'error');
            });
        });
        
        // Function to open delete confirmation modal
        function openDeleteModal(questionId) {
            currentQuestionId = questionId;
            
            // Show modal
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteQuestionModal'));
            deleteModal.show();
        }
        
        // Handle delete confirmation
        document.getElementById('confirmDeleteQuestion').addEventListener('click', function() {
            const button = this;
            const originalContent = button.innerHTML;
            let isDeleting = false;
            
            // Prevent duplicate submissions
            if (isDeleting) return;
            
            // Show loading spinner
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Deleting...';
            button.disabled = true;
            isDeleting = true;
            
            if (!currentQuestionId) return;
            
            // Delete the question
            fetch(`/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions/${currentQuestionId}`, {
                method: 'DELETE',
                headers: { 
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                console.log('Server response status:', response.status);
                
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    return response.json().then(data => {
                        return { status: response.status, body: data };
                    });
                } else {
                    console.warn('Server returned non-JSON response - checking delete status...');
                    return new Promise(resolve => {
                        setTimeout(() => {
                            // Try to check if question still exists
                            fetch(`/instructor/modules/<%= module.module_id %>/quizzes/<%= quiz.quiz_id %>/questions/data`)
                                .then(res => res.json())
                                .then(data => {
                                    // Check if the question is gone
                                    const stillExists = data.questions.some(q => q.question_id == currentQuestionId);
                                    if (!stillExists) {
                                        resolve({ 
                                            status: 200, 
                                            body: { 
                                                success: true, 
                                                message: 'Question deleted successfully' 
                                            } 
                                        });
                                    } else {
                                        resolve({ 
                                            status: 500, 
                                            body: { 
                                                success: false, 
                                                message: 'Question may not have been deleted' 
                                            } 
                                        });
                                    }
                                })
                                .catch(() => {
                                    resolve({ 
                                        status: 500, 
                                        body: { 
                                            success: false, 
                                            message: 'Error verifying question deletion' 
                                        }
                                    });
                                });
                        }, 1000);
                    });
                }
            })
            .then(result => {
                // Reset button state
                button.innerHTML = originalContent;
                button.disabled = false;
                isDeleting = false;
                
                if (result.body.success) {
                    // Hide modal
                    const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteQuestionModal'));
                    deleteModal.hide();
                    
                    // Reload questions
                    loadQuestions();
                    
                    // Show success message
                    showToast('Question deleted successfully!', 'success');
                } else {
                    // Show error message
                    showToast(`Error: ${result.body.message || 'Failed to delete question'}`, 'error'); 
                }
            })
            .catch(error => {
                // Reset button state
                button.innerHTML = originalContent;
                button.disabled = false;
                isDeleting = false;
                
                console.error('Error deleting question:', error);
                showToast(`An error occurred: ${error.message || 'Unknown error'}`, 'error');
            });
        });
        
        // Add loading indicators to edit and delete buttons when they're clicked
        document.addEventListener('click', function(e) {
            // Handle edit button clicks
            if (e.target.closest('.edit-question')) {
                const button = e.target.closest('.edit-question');
                const originalContent = button.innerHTML;
                
                // Show loading spinner
                button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
                button.disabled = true;
                
                // Restore button after delay (in a real app, this would be after the edit modal is loaded)
                setTimeout(() => {
                    button.innerHTML = originalContent;
                    button.disabled = false;
                }, 500);
            }
            
            // Handle delete button clicks
            if (e.target.closest('.delete-question')) {
                const button = e.target.closest('.delete-question');
                const originalContent = button.innerHTML;
                
                // Show loading spinner
                button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
                button.disabled = true;
                
                // Restore button after delay (in a real app, this would be after the delete modal is shown)
                setTimeout(() => {
                    button.innerHTML = originalContent;
                    button.disabled = false;
                }, 500);
            }
        });
        
        // Add loading indicator to save changes button in edit modal
        document.getElementById('saveQuestionChanges')?.addEventListener('click', function() {
            const button = this;
            const originalContent = button.innerHTML;
            
            // Show loading spinner
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
            button.disabled = true;
            
            // The actual save logic would handle restoring the button state
            // For demonstration, we'll restore after a short delay
            setTimeout(() => {
                button.innerHTML = originalContent;
                button.disabled = false;
            }, 2000);
        });
        
        // Add loading indicator to delete confirmation button
        document.getElementById('confirmDeleteQuestion')?.addEventListener('click', function() {
            const button = this;
            const originalContent = button.innerHTML;
            
            // Show loading spinner
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Deleting...';
            button.disabled = true;
        });
    });
</script> 